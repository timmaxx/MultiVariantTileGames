27.09.2023 ------------------------------------------------------------------------------------------------------------

- Написать бизнес-требования на текущую работающую версию.

- Написать ТЗ на текущую работающую версию.

BaseModel
- Классы Tile, Direction, DxDy назовём группа 1.
  BaseModel, View, [ ObservableModel, ViewInterface, ViewMainArea] назовём группа 2 (BaseModel).
  Группа 1 и 2 сейчас не связаны.
  Вероятно нужно:
-- Либо разделить на разные модули;
-- Либо BaseModel должна зависеть от Tile.

- Группа 1 сейчас может работать с перемещением относительно ячейки, но:
-- Не всем играм и нужны перемещения (например Сапёр);
-- Возможно перемещение привязать к независимо-перемещающемуся объекту (ведь в Сокобане ящик перемещается не сам,
   а потому, что его толкает игрок);
--- Перемещение вообще может быть групповым и однонаправленным (например Space Invaders - там инопланетные корабли
    (каждый из которых уже не одноячеечный объект) перемещаются синхронно влево-вправо-вниз, а вот Tetris - там падает
    одна 4-х ячеечная фигурка - это не группа объектов).

- Нужно предоставить возможность отдельному контроллеру запрашивать состояние чего-либо в игре (ячейки, объекта,
  времени, состояния) и при этом только для него и писать такие сообщения.

Архитектура
Вероятно отдельный модуль Интернационализации
- Внедрить мультиязычность для:
-- текстовых выборок (поток вывода и поток вывода ошибок),
-- подписей к контролерам и выборкам,
-- контроллеров-интерпретаторов команд,
-- тул-типов,
-- для меню,
-- и всего прочего.

Примеры реализации View (как JFX, так и в других GUI)
- Варианты игрового поля для различных игр, могут иметь различия в отображении главного поля, например:
-- шахматная раскраска,
-- для игры Го камни ставятся на перекрестие,
-- для игры в нарды в модели поле может быть 2 х 12, а вот изображать его - нужно подумать.

Архитектура
Абстрактная визуализации
- Сделать отдельный модуль, отвечающий за абстрактную визуализацию, в который вывести общее для любых графических
  библиотек (и даже для JavaScript), например:
-- символы, цвета, картинки, размеры, стили.
-- анимацию?

- Реализовать легенду (надписи о координатах ячеек) слева, справа, сверху, снизу (все четыре должны быть необязательные).
-- В т.ч. с различными вариантами символов (цифры, буквы различного алфавита (UP/low), произвольный перечень слов).
-- На ячейках, где легенда, не должно быть реакции от мыши.

Архитектура
Мета-модель
- Ввести понятие мета-модель, которое должно:
-- вести игру между уровнями (там могут быть различные планы уровней и прочее).
--- в т.ч. задавать ширину / высоту и прочие параметры для отдельной партии.

Архитектура
?
- После введения мета-модели ввести в различные варианты визуализации (JavaFX, JavaScript) меню игры,
  в которой видеть и/или редактировать можно будет параметры мета-модели.

BaseModel
- У Морского боя два поля - по одному у каждого игрока. Это как-то не укладывается в текущую модель. Варианты:
-- Игрок либо может играть только с одним полем, которое в модели (общее поле) (т.е. игнорировать Морской бой с его
   своими полями для каждого игрока),
-- Либо в модель ввести перечисление с такими вариантами:
--- в игре только одно поле - общее (для почти всех игр, кроме Морского боя).
--- каждый игрок имеет своё поле, которое принадлежит только ему (частное поле) и нет общего поля (для Морского боя).
--- комбинация, т.е. есть и одно общее поле и два частных поля (пример игры в голову не приходит).

Архитектура
В разных модулях реализовывать сборки "всё в одном" и части системы для клиент-серверных вариантов.
- Можно создать несколько видов компоновки и запуска приложений:
-- "всё в одном" - уже реализовано. Но подойдёт он только для игр с одним игроком (Тетрис, Змейка, Сапер).
-- Для мета-модели, сделать отдельный вид запуска как WebSocket-сервер. Тогда клиенты могут подключаться как:
--- толстыми клиентами (как WebSocket клиенты):
---- десктоп-приложение - различных ПК Windows (JavaFX), (а может и Linux),
---- Android,
---- iOS,
---- Web-сервер, к которому уже можно подключаться браузерами, см. ниже:
-- Веб-приложение внутри себя запускает мета-модель, к которому уже можно подключаться браузерами:
--- html (+ JavaScript) браузеры - тонкий клиент.

Архитектура
- Что-бы выделить мета-модель в сервер, нужно будет придумывать и авторизацию и аутентификацию для отдельных видов
  участников:
-- игрок,
-- наблюдатель,
-- администратор мета-моделей (что-бы уровни загружать).

Архитектура
- Варианты авторизации при подключении к серверу мета-модели:
-- только внутрення БД,
-- внешние варианты, прицепляемые к внутренней БД:
--- локальная ОС
--- доменная ОС
--- google и прочее.

Архитектура
Реализовать класс-контроллер - генерация команд в поток ввода команд.
- Реализовать класс-контроллер, который не будет привязан ни к символам клавиатуры (Scene), ни к кликам мыши (GameStackPane).
  Он должен быть привязан только к модели. Такой контроллер мог-бы стать, например,
  консолью ввода команд. Это типа поток ввода.
  Нужно подумать, на реакцию консоли на:
-- синтаксически не правильные команды,
-- правильные команды с различным откликом в модели:
--- нет изменений (например для Сапёра попытка открыть уже открытую ячейку),
--- нет изменений, т.к. не допустимая команда в контексте (например для Сапёра попытка открыть ячейку, на которой стоит флаг),
--- команда привела к изменению,
--- прочее.

Архитектура
Реализовать представление не графическое - чтение и вывод сообщений из потока вывода и потока вывода ошибок.
- Реализовать представление не графическое. Оно могло-бы выдавать информацию о принятом сообщении в текстовом виде.
  Это было-бы типа чтением из потока вывода и потока вывода ошибок.

MinesweeperModel и MineSweeperViewControlJfx (и др. GUI)
- В контроллере кликов мыши от Сапёра реализовать реакцию от средней кнопки мыши.

Архитектура
BaseModel
- В базовую модель внести возможность работать с играми в реальном режиме времени (Тетрис, Змейка).
-- Предусмотреть количество ходов, которое можно сделать за единицу времени.

Реализовать TetrisModel, TetrisViewControlJfx (и/или др. GUI)
- Реализовать тетрис.

Архитектура
Реализовать TileGameEngine... (где ... это хотя-бы ещё один из вариантов GTK+, AWT, SWT, Swing)
- В качестве альтернативных реализаций выборок и контроллеров, привязанных к графике в десктопном варианте,
  можно было-бы реализовать модули для хотя-бы ещё одного из вариантов:
-- GTK+,
-- AWT,
-- SWT,
-- Swing,
-- JavaFX - первично выбранная библиотека (на ней уже и реализованы первые версии).

Реализовать альтернативную реализацию GUI для одной игры ...ViewControl...
(где: 1-й ... - уже конкретная игра (Minesweeper, Sokoban), 2-й ... это GTK+, AWT, SWT, Swing)
- Например MinesweeperViewControlSwing.

Архитектура
BaseModel
- Внести в модель состояние о классификации игры. Это поможет для:
-- предоставлять или не предоставлять доступ к какому-то базовому функционалу (например для пошаговых игр не нужен таймер,
   или, может быть, не нужен будет доступ к генератору случайных чисел и т.п.),
-- требования по обязательности работы с каким-либо функционалом или требовать не работы с ним.
-- т.е. это будет сдерживать разработчиков от ошибок в реализациях:
--- либо на этапе компиляции (например через интерфейсы (как обязанность реализовать те или иные функции) и
    их реализации в конкретных моделях), что предпочтительнее.
--- либо во время игры, модель может попытаться обратиться к какому-либо функционалу, который ей не должен быть доступен.


30.09.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
- Создать web-приложение сервер, в котором уже сразу будет модель.
-- Клиентом должен стать HTML-JavaScript клиент

Архитектура
HTML-JavaScript клиент
- Создать интерактивный HTML-JavaScript клиент
-- Реализовать визуализацию:
   https://basecourse.ru/javascript/main.php
   Глава 4. События браузера
   Делегирование событий
   https://basecourse.ru/javascript/delegation.php
   JSTutorial
   basecourse.ru_javascript_main.php
   04090305.html
-- Реализовать отправку запросов из браузера на http-сервер
   https://basecourse.ru/ajax/main.php
-- Реализовать получение ответов от http-сервера
--- Вариант почти асинхронный:
    https://basecourse.ru/comet/main.php
--- https://learn.javascript.ru/
    Часть 2.
    Fetch
    XMLHttpRequest
    Сетевые запросы
    Длинные опросы
    WebSocket

Архитектура
- Создать web-приложение сервер, который будет подключаться клиентом к модели:
-- WebSocket...Model.
-- Клиентом должен стать HTML-JavaScript клиент.

Архитектура
MinesweeperModel и SokobanModel
- Модель в Сапёре разделена на MinesweeperModel и AllMinesweeperObjects, в Сокобане модель только в SokobanModel. Нужно
  проанализировать плюсы и минусы обоих вариантов и свести текущие варианты к одному:
-- Либо ...Model и All...Objects.
-- Либо только ...Model.

MinesweeperViewControlsJfx
- Баг (не красиво в визуализации): в MinesweeperPersistentSettings::update и в MinesweeperVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.

SokobanViewControlsJfx
- Баг (не красиво в визуализации): в SokobanPersistentSettings::update и в SokobanVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.


02.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
TileGameEngineJfx
- Сейчас имеются классы потомки ViewJfx, отвечающие за вывод целых значений (постоянных и переменных параметров
  статистики партии) и их потомки, которые могут принимать контроллер в конструкторе, чтобы работать с мышью.
  Но в этом нет необходимости.
  Нужно пересмотреть классы ViewJfx, ViewMainFieldJfx, ViewTextFieldsJfx чтобы каким-то классам предоставить возможность
  работы с мышью, а каким-то нет.
  Например, сделать это через интерфейс "Работа с мышью" и его реализацию в ViewMainFieldJfx или в новом промежуточном
  классе между ViewJfx и ViewMainFieldJfx.


07.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Для того, что-бы модуль "всё в одном" мог и дальше работать (но, как писал ранее, только для одного игрока),
  действия с п. 2 по п. 6 нужно выделить в отдельный модуль. Создать интерфейс/интерфейсы для модели и выборки.
  И сделать несколько реализаций, в т.ч.:
-- очень простая для работы "всё в одном",
-- для работы в сети.


10.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Ввести сущность "роль игрового объекта". Например в Го - это камень, в Шашках - это шашка и дамка, а уж в Шахматах
  и того более... (Также см. заметки) Она будет нести и описательную роль и функциональную.
  Причём роль для отдельных игр может:
-- либо не меняться в течение игры (Го).
-- либо в процессе игры поменяться при определённых обстоятельствах (Шашки, Шахматы).

BaseModel
- BaseModel сделать интерфейсом. В нём продекларировать те же методы, что сейчас у BaseModel.
  Такой подход уменьшит количество переименований по всем пакетам - модулям проекта.
-- Отдельный NetModel, реализующий новый BaseModel, будет для работы выборок и контроллеров с моделями через сеть.


30.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- В текущем варианте модель сообщает выборкам не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Сейчас лог в подобном формате ведётся только для Сокобан. Но его можно было-бы сделать более универсальным.
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

BaseModel
- Изменить порядок регистрации выборки в модели и порядок извещения моделью выборок:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна отправлять сообщения в выборки, на которые были подписки. Если есть событие,
   на которое не было подписки - оно никому не направляется.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.


09.11.2023 ------------------------------------------------------------------------------------------------------------

WebSocketClient
- Этот класс обладает несколькими публичными методами. Но вызов отдельно взятого метода часто зависит от того,
  вызывались-ли какие-то другие до этого или нет. Т.е. можно сказать, что экземпляр WebSocketClient может находиться в
  различных состояниях. Реагировать на вызов метода вне очереди можно по разному:
  Вводим ещё один Enum (например CallResponse):
-- Простейший:
--- Вызывать можно методы текущего состояния,
--- При вызове любого предшествующего метода - откатываемся на то состояние, которое получится в результате.
--- При вызове любого после последующего - исключение.
-- Только шаг вперёд или шаг назад:
--- Вызывать можно только методы текущего состояния,
--- или метод откатывающий на шаг назад,
--- или метод продвигающий на шаг вперёд.
--- в остальных случаях - исключения.

GameClients
- Классы пакета timmax.tilegame.client.statuscontrol можно настраивать в зависимости
  от состояния экземпляра WebSocketClient.
-- Простейший:
--- доступны будут все контролы,
-- Только шаг вперёд или шаг назад:
--- доступны будут только те контролы, вызов которых точно не приведёт к исключению.


18.11.2023 ------------------------------------------------------------------------------------------------------------

MultiGameWebSocketClient, MultiGameWebSocketServer, GameClients
- Когда пользователь постепенно переходит:
-- от не соединённого состояния с сервером к соединённому и наоборот,
-- от не идентифицированного пользователя к авторизованному и наоборот,
-- и т.д. "продвигаясь" к игре партии и в обратную сторону.
  Нужно:
-- При вызове методов проверять, допустимо-ли вызывать определённый метод в текущем состоянии.
   Если не допустимо - создавать исключение.


20.02.2024 ------------------------------------------------------------------------------------------------------------

Несколько классов и методов, где есть использование рефлексии. Нужно упорядочить.

LocalClientState::
// ---- 4 (Конкретный тип игры)
    @Override
    public void setGameType(ModelOfServerDescriptor modelOfServerDescriptor) {...
      Ищется конструктор выборки с определённым типом параметров.
      Вызывается конструктор и создаются выборки.
    }

LocalClientStateJfx::
    @Override
    public Constructor<? extends View> getViewConstructor(Class<? extends View> classOfView, BaseController baseController, String viewName) {
      Для интерфейса типа Class<? extends View> (ViewMainField или View) предоставляет
        соответствующий конструктор Jfx (ViewMainFieldJfx или ViewJfx)
    }

ModelOfServerDescriptor::
    public ModelOfServerDescriptor(String modelOfServerString,
                                   // ToDo: Возможно перечень выборок здесь и не нужен.
                                   //       Пересмотреть архитектуру и возможно удалить.
                                   //       Также см. ModelOfServerLoader
                                   Map<String, Class <? extends View>> mapOfViewNameViewClass,
                                   RemoteClientState remoteClientState)
            throws ClassNotFoundException, NoSuchMethodException {
      Ищется класс по имени, заданному строкой.
      Ищется конструктор модели с определённым типом параметров.
      Вызывается конструктор и создаётся модель.
    }

EventOfClient61SetGameMatch::
    @Override
    public <ClientId> void executeOnServer(TransportOfServer<ClientId> transportOfServer, ClientId clientId) {
      Ищется класс по ModelOfServerDescriptor.
      Ищется конструктор модели с определённым типом параметров.
      Вызывается конструктор и создаётся модель.
    }

GameClientPaneJfx::
    public GameClientPaneJfx(
            IModelOfClient iModelOfClient,
            TransportOfClient transportOfClient) {
      Ищется Jfx класс выборки.
      Ищется конструктор выборки.
      Вызывается конструктор и создаются выборки.
    }
