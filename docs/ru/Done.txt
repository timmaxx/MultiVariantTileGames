01.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
MinesweeperModel
- Класс GameEventMinesweeperVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- GameEventMinesweeperVariableParams.
-- AllMinesweeperObjects.

(30.09.2023)
MinesweeperViewControlsJfx
- Класс GameEventMinesweeperVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- MinesweeperVariableSettings.

(30.09.2023)
SokobanModel
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanModel.
-- GameEventSokobanVariableParams.

(30.09.2023)
SokobanViewControlsJfx
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanVariableSettings.


02.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
Архитектура
TileGameEngineJfx
- Подготовить модуль для унификации классов потомков ViewJfx, отвечающих за вывод целых значений
  (постоянных и переменных параметров статистики партии) и их потомков в связи с их похожестью:
-- MinesweeperPersistentSettings, MinesweeperVariableSettings,
-- SokobanPersistentSettings, SokobanVariableSettings.

(30.09.2023)
Архитектура
MinesweeperViewControlsJfx
- Классы MinesweeperPersistentSettings, MinesweeperVariableSettings и их потомки очень похожи.
-- Их нужно унифицировать и общее вывести в новый родительский класс.

(30.09.2023)
Архитектура
SokobanViewControlsJfx
- SokobanPersistentSettings, SokobanVariableSettings и их потомки очень похожи.
-- Их нужно унифицировать и общее вывести в новый родительский класс.


05.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
Архитектура
TileGameEngineJfx
- Подготовить модуль для унификации классов потомков ViewJfx, отвечающих за вывод целых значений
  (постоянных и переменных параметров статистики партии) и их потомков в связи с их работой более чем с одним полем вывода:
-- MinesweeperPersistentSettings, MinesweeperVariableSettings,
-- SokobanPersistentSettings, SokobanVariableSettings.

(30.09.2023) В коммите есть попытка реализации в BaseModel. Неуспешная. Будет удалена. Отказ от реализации.
Архитектура
BaseModel и наследники (MinesweeperModel и SokobanModel)
- Класс GameEventROTextFields пустой (в BaseModel) и его наследники GameEventMinesweeper... (в MinesweeperModel
  не могут при наследовании иметь независимую static переменную.
  Эта задача похоже связана с задачей от 30.09.2023 "Подготовить модуль для унификации классов потомков ViewJfx,
  отвечающих за вывод целых значений (постоянных и переменных параметров статистики партии) и их потомков в связи с их
  работой более чем с одним полем вывода".
  Нужно найти более правильное архитектурное решение. Вероятно оно будет связано с введением в базовый класс списка
  параметров для вывода в выборку, где элементом списка было-бы: заголовок, тип, значение.
-- Причем сейчас тип только int, а ведь возможно там и другой тип может быть, например текст или Enum.
-- Даже при этом универсальном виде заголовок и тип - значения всегда одинаковые в списке для отдельно взятого типа
   сообщения.

(05.10.2023)
Архитектура
MinesweeperModel и MinesweeperViewControlsJfx
- Удалить константы из кода функций Minesweeper...Settings... и перенести их в классы:
-- либо GameEventMinesweeper...,
-- либо преобразовать в другое архитектурное решение (см. следующую задачу).

(30.09.2023) Отказ от реализации.
Архитектура
MinesweeperViewControlsJfx
- Классы MinesweeperPersistentSettings, MinesweeperVariableSettings и их потомки очень похожи.
-- После первой унификации учесть не только один параметр, а унифицировать для более чем одного параметра.

(05.10.2023)
Архитектура
SokobanModel и SokobanViewControlsJfx
- Удалить константы из кода функций Sokoban...Settings... и перенести их в классы:
-- либо GameEventSokoban...,
-- либо преобразовать в другое архитектурное решение (см. следующую задачу).

(30.09.2023) Отказ от реализации.
Архитектура
SokobanViewControlsJfx
- SokobanPersistentSettings, SokobanVariableSettings и их потомки очень похожи.
-- После первой унификации учесть не только один параметр, а унифицировать для более чем одного параметра.


07.10.2023 ------------------------------------------------------------------------------------------------------------

(27.09.2023)
BaseModel
- В модели очередь сообщений сначала очень упростить в реализации.

(30.09.2023) - Частично. Т.е. не реализовывал Server Sent Events. Выбран WebSocket.
Найдена библиотека Java-WebSocket. И из примеров сначала повторен чат-сервер и чат-клиенты, а потом ещё и отрефакторены
  и унифицировано поведение для чат-клиентов со Swing и с Console-интерфейсами.
Архитектура
- Выбрать WebSocket и Server Sent Events как технологии по оперативному обмену событиями между участниками соединения,
  а может вообще что-то другое:
-- Изучить в теории (в т.ч. плюсы и минусы),
-- Отдельно собрать простые примеры,
-- Выбрать один из них.


09.10.2023 ------------------------------------------------------------------------------------------------------------

(09.10.2023) - почти, т.к. timmax.tilegame.game.minesweeper.server и client ещё не реализованы
Архитектура
Все модули
- Переделать структуру и имена пакетов:
  timmax.tilegame - корень всего многомодульного проекта
-- Модуль BaseTileModel - базовая абстрактная модель и выборки:
--- timmax.tilegame.basemodel
--- timmax.tilegame.baseview
-- Модуль BaseGameEngineJFX - движок для отрисовки в десктопном варианте на JavaFX:
--- timmax.tilegame.guiengine
---- timmax.tilegame.guiengine.swing - такого пакета сейчас нет, но если-бы он появился,
     то его нужно делать в другом модуле, но с этим именем.
---- timmax.tilegame.guiengine.jfx - корень модуля для реализации JavaFX движка
----- timmax.tilegame.guiengine.jfx.view - типовые выборки
----- timmax.tilegame.guiengine.jfx.controller - типовые контроллеры
-- timmax.tilegame.game - пакет, в котором уже будут реализованы конкретные виды игр.
   В отдельных пакетах и модулях модель игры, в отдельных выборки и контроллеры, в отдельных сборка запускаемых вариантов.
   Например:
-- Модуль MinesweeperModel - реализует модель игры Сапёр
--- timmax.tilegame.game.minesweeper.model
-- Модуль MinesweeperViewControlJFX - реализует визуализацию и приём команд от мыши и клавиатуры для игры Сапёр на JavaFX
--- timmax.tilegame.game.minesweeper.jfx
--- timmax.tilegame.game.minesweeper.jfx.view - выборки (визуализация)
--- timmax.tilegame.game.minesweeper.jfx.control - контроллеры (приём команд от мыши и клавиатуры)
-- Модуль MinesweeperGame - различные варианты запуска
   (думаю, что и этот модуль нужно разделить на несколько - по количеству видов сборки, но зато архитектуру стоит
   унифицировать и уйти от конкретной игры в сборке)
--- timmax.tilegame.game.minesweeper.all_in_one - в сборке и модель и выборки с контроллерами - исполняемый модуль не
    работает с сетью (только для игр с одним игроком).
--- timmax.tilegame.game.minesweeper.server.websocket - сборка только модели, запускаемой как сервер и работающий
    по WebSocket протоколу. Никакого GUI не предусмотрено.
    Будет допускать подключение более чем одного игрока и наблюдателей.
--- timmax.tilegame.game.minesweeper.client.websocket - сборка только клиента (выборки и контроллеры),
    который может подключиться к серверу по WebSocket протоколу. Будет работать как игрок или наблюдатель.
--- timmax.tilegame.game.minesweeper.client.websocket.jfx - реализация клиентского GUI через JavaFX.


10.10.2023 ------------------------------------------------------------------------------------------------------------

(10.10.2023)
MinesweeperGameStackPaneController
- В контроллере Minesweeper есть код, обращающийся к модели к состоянию игры. А этим должны заниматься выборки,
  а не контроллеры! Например, в отдельный метод, который вызывать при каждом поступлении любой команды.
-- Убрать в модель.
-- удалить геттеры в моделях.

(10.10.2023)
SokobanGameSceneController
- В контроллере SokobanGame есть код, обращающийся к модели к состоянию игры. А этим должны заниматься выборки,
  а не контроллеры! Например, в отдельный метод, который вызывать при каждом поступлении любой команды.
-- Убрать в модель.
-- удалить геттеры в моделях.

(10.10.2023) Отказ от реализации.
View, ViewJfx (и наследники)
- Класс View сейчас не используется, но там есть базовый функционал. Нужно отрефакторить ViewJfx, что-бы было использование.

(27.09.2023)
BaseModel
- Дополнить модель очередью команд. Именно в эту очередь должны писать контроллеры.


15.10.2023 ------------------------------------------------------------------------------------------------------------

(15.10.2023)
MinesweeperModel
- Исправлена ошибка в модели Сапёра: при попытке инвертировать флаг на уже открытой плитке исключение возникало
  (о том, что инвертировать флаг для открытой плитки нельзя), и оно же вываливалось и в консоль.

(15.10.2023) частично
BaseModel
- BaseModel сделать интерфейсом. В нём продекларировать те же методы, что сейчас у BaseModel.
  Такой подход уменьшит количество переименований по всем пакетам - модулям проекта.
-- Текущий BaseModel сделать ServerBaseModel, реализующий новый BaseModel.


26.10.2023 ------------------------------------------------------------------------------------------------------------

(07.10.2023) Отказ от реализации очередей.
Архитектура
BaseModel
- Сейчас в BaseModel в исходящую очередь добавляются сообщения, а при вызове notify вызываются update, каждой
  присоединённой view. Такое подходит, когда модель и выборка в одном исполняемом коде.
  Для сетевого взаимодействия нужно разделить функционал на:
-- 1. М: внесению сообщений от модели в очередь модели,
-- 2. М: передача по сети сообщений из очереди модели,
-- 3. В: приём по сети сообщений в выборке,
-- 4. В: внесение в очередь входящих сообщений на стороне выборки,
-- 5. В: известить модель (дать отклик), что сообщение получено,
-- 6. М: если модель получила отклик, что сообщение получено выборкой, то удалить его из своей очереди,
-- 7. В: вызов update на стороне выборки,
-- 8. В: удаление сообщения из очереди выборки.

(10.10.2023) Отказ от реализации очередей.
BaseModel, ...View
- Сейчас очереди сообщений (от модели к выборкам) находятся в модели (т.к. реализована сборка типа "всё-в-одном").
  Для последующей реализации других вариантов сборки нужно создать свои экземпляры очередей в каждой из выборок.
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очереди в модели в очереди в выборки.

(10.10.2023) Отказ от реализации очередей.
BaseModel, ...Controller
- Кроме того, что в модели должна появиться очередь команд, в каждом из контроллеров должна также появиться своя очередь
  команд.
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очередей в контроллерах в очередь в модели.

(07.10.2023)
Архитектура
- Создать отдельный пакет в BaseModel (модуль потом) с данными для авторизации: имя / пароль, и парой готовых записей.

(30.09.2023)
Архитектура
WebSocketModel и WebViewControlJfx
- Создать отдельные модули по запуску только модели и только клиента:
-- Оба модуля с использованием WebSocket.
-- Вероятно конкретные названия модулей будут:
--- WebSocket...Model.
--- WebViewControl...Jfx.


30.10.2023 ------------------------------------------------------------------------------------------------------------

(30.10.2023) Отказ от реализации
BaseModel
TransportPackage
- Оптимизация наследников TransportPackage
  Сейчас initMapOfStructOfTransportPackage() реализован в классах наследниках. Из-за этого в них приходится дублировать
  конструкторы.
  Предлагается реализовать initMapOfStructOfTransportPackage() в отдельном сервисном классе и аргументом ему передавать
  this.getClass().
  Тогда классы-наследники этого класса удалим.

(27.09.2023) Отказ от реализации очередей.
Архитектура
BaseModel
- Текущий вариант очереди сообщений содержит в себе не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

(27.09.2023) Отказ от реализации очередей.
BaseModel
- Очередь сообщений изменить:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна писать в одну очередь все события, на которые были подписки. Если есть событие,
   на которое не было подписки - оно не пишется в очередь.
-- Чтение из очереди отдельно взятой выборкой не должно приводить к удалению прочтённого сообщения.
   Но где-то в очереди нужно фиксировать, что такая-то выборка прочитала последнее такое-то сообщение.
-- Удаление сообщения из очереди должно происходить тогда, когда сообщение было прочитано всеми выборками.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.

10.11.2023 ------------------------------------------------------------------------------------------------------------

(09.11.2023)
GameClients
- Если сразу после запуска приложения закрыть его, то приложение закроется. Но если сделать соединение с сервером и
  попытаться закрыть соединение, то окно приложения закроется, а приложение останется в памяти. Если-же после запуска
  приложения сделать соединение, потом разъединение, то приложение закроется.
  (Вероятно при установлении соединения запускается нить-поток. И даже если закрыть GUI приложения, то нить всё ещё
  продолжает работу).
-- Нужно отловить событие JavaFX о закрытии GUI (например при щелчке на крестике) и завершить все дочерние потоки.


12.11.2023 ------------------------------------------------------------------------------------------------------------

(09.11.2023)
- Реализовать в протоколе и в применении обмен сообщением типа GET_GAME_TYPE_SET

(12.11.2023)
- Отказаться от "двухскобочной инициализации" во всех классах. Из-за антишаблонности такого решения.


13.11.2023 ------------------------------------------------------------------------------------------------------------

(12.11.2023)
WebSocketClient
- Класс обладает особенностью, заключающейся в том, что после успешного соединения и потом разъединения,
  его не получается использовать повторно. Из-за этого приходится усложнять логику вне этого класса при событиях
  соединения и разъединения.
  Попробовать реализовать класс, в котором будет внутри будет WebSocketClient и этот экземпляр будет постоянным и
  он будет работать с WebSocketClient. В т.ч. создавать его при необходимости.


16.11.2023 ------------------------------------------------------------------------------------------------------------

(16.11.2023)
- Реализовать в протоколе и в применении обмен сообщением типа FORGET_GAME_TYPE_SET


18.11.2023 ------------------------------------------------------------------------------------------------------------

(18.11.2023)
- Если к серверу обращаются с TypeOfTransportPackage.LOGIN. То сервер сейчас отвечает только LOGIN. При этом если логин
  был не удачный, то клиенту сообщается ResultOfCredential.NOT_AUTHORISED и пустое имя пользователя.
  Лучше уж пусть сервер отвечает LOGOUT. Так и проще и от класса ResultOfCredential избавимся.

(23.10.2023)
Архитектура
BaseModel, WebSocketServer, WebSocketClient
- Сейчас в BaseModel в исходящую очередь добавляются сообщения, а при вызове notify вызываются update, каждой
  присоединённой view. Такое подходит, когда модель и выборка в одном исполняемом коде.
  Отказываемся от очередей.
  Для сетевого взаимодействия нужно разделить функционал на MVC
  (М - модель (сервер), В - выборка (клиент), К - контроллер (клиент)):
-- Инициатор - К:
--- 1. К: запрос информации или отправление команды в Модель,
--- 2. М: приём по сети сообщений в основном потоке WebSocket сервера.
          Передача в поток отдельной модели.
-- Инициатор - М:
--- 1. М: Когда в Модели происходят изменения, отправляем сообщения всем выборкам, присоединённым к данной модели
          (и желательно подписанных на определённый тип сообщений).
--- 2. В: приём в основном потоке WebSocket клиента (каждого, кто подключен к определённой модели).
          Передача сообщения в JavaFX поток в каждую выборку (на тип сообщений которые подписано).
          Выборка себя обновляет.

(23.10.2023)
Архитектура
- Реализовать простой WebSocketServer и WebSocketClient. В которых реализовать протокол взаимодействия между клиентом и
  сервером.
-- Каждое из типов сообщений сервера так или иначе делается в ответ на запрос клиента.
-- Для WebSocketClient предложить и реализовать взаимодействие со своими собственными контроллерами и выборками в
   асинхронном режиме.

(30.10.2023)
MultiGameWebSocketClient, MultiGameWebSocketServer, GameClients
- Когда пользователь постепенно переходит:
-- от не соединённого состояния с сервером к соединённому и наоборот,
-- от не идентифицированного пользователя к авторизованному и наоборот,
-- и т.д. "продвигаясь" к игре партии и в обратную сторону.
  Нужно:
-- Накапливать данные о состоянии (например ч/з Optional) по пути к игре и стирать данные о состоянии в обратном порядке.
-- Обеспечить механизм работы с контролами JavaFX
--- Со стороны контролов:
---- Присоединение к MultiGameWebSocketClient.
     Кнопки и поля ввода, которые можно пока для простоты объединить в готовые к применению классы
     из нескольких контролов под различные состояния, например:
----- 1. ТекстПоле сервер, ТекстПоле порт, Кнопка коннект, Кнопка дисконнект.
----- 2. ТекстПоле имяПользователя, ПарольТекстПоле пароль, Кнопка войти, Кнопка выйти.
         (где-то здесь и регистрацию нового пользователя потом влепить).
----- 3. Список типИгры, Кнопка выбрать, Кнопка назад.
----- ...
     В т.ч. настройка умолчательного поведения
     (т.е. при нажатии на кнопку, которая присоединена к методу login, должна вызываться login без дополнительной
     настройки кода. Это можно делать при объединении контролов в блоки).
     И в т.ч. при поступлении об изменении состояния MultiGameWebSocketClient делать доступным либо не доступным
     отдельные контролы.
--- Со стороны MultiGameWebSocketClient:
---- Запоминание присоединенных контролов к MultiGameWebSocketClient (например при создании группового контрола),
---- доступность контролов (setDisable) должна также регулироваться состоянием MultiGameWebSocketClient
     (к-рое в свою очередь изменяется при поступлении того или иного сообщения от сервера).


19.11.2023 ------------------------------------------------------------------------------------------------------------

(19.11.2023)
- Реализовать в протоколе и в применении обмен сообщением типа FORGET_GAME_TYPE


24.02.2024 ------------------------------------------------------------------------------------------------------------

(24.02.2024)
Внести структурные изменения
1. Из interface TransportOfClient удалить дублирующиеся методы interface IModelOfClient.


26.02.2024 ------------------------------------------------------------------------------------------------------------

(24.02.2024)
Внести структурные изменения
2. Пересмотреть интерфейсы и их реализации: TransportOfClient, TransportOfServer, IModelOfClient, IModelOfServer.


27.02.2024 ------------------------------------------------------------------------------------------------------------

(24.02.2024)
Внести структурные изменения
4. Начать уже использовать логирование, а не велосипедить.


06.03.2024 ------------------------------------------------------------------------------------------------------------

(24.02.2024)
Внести структурные изменения:

5. Сократить перечень Pane0xXxx и методов interface IModelOfClient и классов EventOfClient / EventOfServer
   (30, 31, 50, 51). Удалить:
5.1. Pane03. Пусть Pane02 получает перечень типов игр. IModelOfClient удалить 3. EventOfClient / EventOfServer (30, 31)
5.2. Pane05. Пусть Pane04 получает перечень конкретных матчей. IModelOfClient удалить 5. EventOfClient / EventOfServer (50, 51)
Pane02 и Pane04 не сокращены, но клиент автоматически запрашивает перечень типов игр при успешном входе и перечень
партий после выбора типа игры.


12.03.2024 ------------------------------------------------------------------------------------------------------------

(24.02.2024)
На этот момент есть несколько ближайших функционалов, которые можно реализовывать:

1. При подключении к новой игре (т.е. которая ещё ни разу не запускалась), должна быть возможность ввести параметры,
   специфичные для данного типа игры (например, для Сапёра это размер поля и количество мин).
   (Но сделано не очень красиво и даже не всегда очевидно).