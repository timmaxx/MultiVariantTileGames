Sokoban на Swing:
package com.javarush.task.task34.task3410.controller;


Для реализации классификации игры можно рассмотреть такой вариант:
На каждый из классификаторов создать по интерфейсу.
А на каждую из альтернатив по отдельной классификации сделать классы, реализующие этот интерфейс, но реализующим его в
  соответствии с вариантом классификации.
Каждая модель будет иметь по одной переменной каждого такого интерфейса, в которую будет записана переменная,
  реализующая определённый интерфейс в определённом варианте классификации.
Вот и не получится, что-бы модель, по отдельной классификации, удовлетворяла более чем одной версии классификации!


Пример реализации классов в Шахматах относительно ролей.
- Заметка для Шахмат: пешка может стать любой фигурой, кроме короля, а значит в иерархии классов будет:
-- Объект Шахмат:
--- Пешка
--- Фигуры:
---- Король
---- Фигуры, но не король:
----- Ладья,
----- Конь,
----- Слон,
----- Ферзь.


Последовательности при создании клиентов и сервера и при создании команд и событий

Последовательность при сборке сервера игры для контроллера:
1. ???

Последовательность при сборке клиента игры для контроллера:
1. вызываются:
1.1. initGameSceneController( baseModel) (по одному на каждую выборку - отвечает за реакцию от мыши).
1.2. initGameStackPaneController( baseModel) (один на всю сбоку - отвечает за нажатие клавиш).
   каждый из которых запоминает ссылку на модель и создаёт внутри себя очередь GameCommandQueueOfController.
   (в которую потом и будет писать команды).
   Т.е. у каждого контроллера своя очередь команд.
   Во время или до "запоминания ссылки на модель" нужно проводить идентификацию клиента на сервере
   и допускать клиента только к определённым играм и определённым ролям.

Последовательность при возникновении команды
1. Контроллер (в клиенте) создаёт команду
2. Команда записывается в очередь команд этого контроллера.
3. Транспорт:
3.1. Из очереди команд контролера вытаскивается команда
3.2. Команда передаётся в очередь команд модели
4. Модель вытаскивает команду из очереди команд
5. Исполняет команду.

Последовательность при возникновении регистрации выборки:
1. Во время или до "регистрации выборки в модели" нужно проводить идентификацию клиента на сервере
   и допускать клиента только к определённым играм и определённым ролям.
2. Сборка (клиент игры) вызывает в своей модели (удалённая модель) регистрацию выборки в модели.
3. Модель (удалённая модель) обращается к модели (реальная-серверная) с предложением регистрации выборки.
4. Серверная модель создаёт в карте выборка-очередь новую запись, где выборка должна быть сохранена вместе
   с информацией о соединении к выборке (локальное или WebSocket) и новую очередь.

Последовательность при возникновении события:
1. Серверная модель в цикле по всей карте выборка-очередь проходит и:
1.1. запихивает в каждую очередь (серверную) событие.
2. Серверная очередь, получив событие:
2.1. извлекает его из себя
2.2. направляет в клиентскую очередь выборки:
2.2.1. в карте выборка-очередь в выборке есть инфа о соединении с выборкой
3. Клиентская очередь, получив событие:
3.1. вызывает update, которое:
3.1.1. вытаскивает событие из своей удалённой очереди.
3.1.2. обновляет отрисовку выборки.


Роли подключающихся клиентов:
1. Админ. Видимо это отдельный клиент.
2. Игрок N.
3. Наблюдатель. Т.е. нет возможности взаимодействия с моделью - контроллеры не подключены к модели.
3.1. Полный наблюдатель. Тот, кто может видеть всё поле/поля и объекты игры, даже если они частично скрыты:
3.1.1. Либо это большинство игр с одним видимым для всех полем:
3.1.1.1. Шашки - наблюдатель (как и любой игрок) видит всё,
3.1.1.2. В игре есть скрытая информация (Судоку, Сапёр):
3.1.1.2.1. только полный наблюдатель видит всё поле сразу,
3.1.1.2.2. наблюдатель, но не полный - видит, только то, что видит игрок (из этой ветки вынести нужно).
3.1.2. либо он видит все персональные поля всё время - Морской бой).
3.2. Наблюдатель за игроком N (в случае, если поля у игроков отличаются, например Морской бой).