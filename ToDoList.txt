27.09.2023 ------------------------------------------------------------------------------------------------------------

- Написать бизнес-требования на текущую работающую версию.

- Написать ТЗ на текущую работающую версию.

BaseModel
- Классы Tile, Direction, DxDy назовём группа 1.
  BaseModel, View, [ ObservableModel, ViewInterface, ViewMainArea] назовём группа 2 (BaseModel).
  Группа 1 и 2 сейчас не связаны.
  Вероятно нужно:
-- Либо разделить на разные модули;
-- Либо BaseModel должна зависеть от Tile.

- Группа 1 сейчас может работать с перемещением относительно ячейки, но:
-- Не всем играм и нужны перемещения (например Сапёр);
-- Возможно перемещение привязать к независимо-перемещающемуся объекту (ведь в Сокобане ящик перемещается не сам,
   а потому, что его толкает игрок);
--- Перемещение вообще может быть групповым и однонаправленным (например Space Invaders - там инопланетные корабли
    (каждый из которых уже не одноячеечный объект) перемещаются синхронно влево-вправо-вниз, а вот Tetris - там падает
    одна 4-х ячеечная фигурка - это не группа объектов).

- Нужно предоставить возможность отдельному контроллеру запрашивать состояние чего-либо в игре (ячейки, объекта,
  времени, состояния) и при этом только для него и писать такие сообщения.

Архитектура
Вероятно отдельный модуль Интернационализации
- Внедрить мультиязычность для:
-- текстовых выборок (поток вывода и поток вывода ошибок),
-- подписей к контролерам и выборкам,
-- контроллеров-интерпретаторов команд,
-- тул-типов,
-- для меню,
-- и всего прочего.

Примеры реализации View (как JFX, так и в других GUI)
- Варианты игрового поля для различных игр, могут иметь различия в отображении главного поля, например:
-- шахматная раскраска,
-- для игры Го камни ставятся на перекрестие,
-- для игры в нарды в модели поле может быть 2 х 12, а вот изображать его - нужно подумать.

Архитектура
Абстрактная визуализации
- Сделать отдельный модуль, отвечающий за абстрактную визуализацию, в который вывести общее для любых графических
  библиотек (и даже для JavaScript), например:
-- символы, цвета, картинки, размеры, стили.
-- анимацию?

- Реализовать легенду (надписи о координатах ячеек) слева, справа, сверху, снизу (все четыре должны быть необязательные).
-- В т.ч. с различными вариантами символов (цифры, буквы различного алфавита (UP/low), произвольный перечень слов).
-- На ячейках, где легенда, не должно быть реакции от мыши.

Архитектура
Мета-модель
- Ввести понятие мета-модель, которое должно:
-- вести игру между уровнями (там могут быть различные планы уровней и прочее).
--- в т.ч. задавать ширину / высоту и прочие параметры для отдельной партии.

Архитектура
?
- После введения мета-модели ввести в различные варианты визуализации (JavaFX, JavaScript) меню игры,
  в которой видеть и/или редактировать можно будет параметры мета-модели.

BaseModel
- У Морского боя два поля - по одному у каждого игрока. Это как-то не укладывается в текущую модель. Варианты:
-- Игрок либо может играть только с одним полем, которое в модели (общее поле) (т.е. игнорировать Морской бой с его
   своими полями для каждого игрока),
-- Либо в модель ввести перечисление с такими вариантами:
--- в игре только одно поле - общее (для почти всех игр, кроме Морского боя).
--- каждый игрок имеет своё поле, которое принадлежит только ему (частное поле) и нет общего поля (для Морского боя).
--- комбинация, т.е. есть и одно общее поле и два частных поля (пример игры в голову не приходит).

Архитектура
В разных модулях реализовывать сборки "всё в одном" и части системы для клиент-серверных вариантов.
- Можно создать несколько видов компоновки и запуска приложений:
-- "всё в одном" - уже реализовано. Но подойдёт он только для игр с одним игроком (Тетрис, Змейка, Сапер).
-- Для мета-модели, сделать отдельный вид запуска как WebSocket-сервер. Тогда клиенты могут подключаться как:
--- толстыми клиентами (как WebSocket клиенты):
---- десктоп-приложение - различных ПК Windows (JavaFX), (а может и Linux),
---- Android,
---- iOS,
---- Web-сервер, к которому уже можно подключаться браузерами, см. ниже:
-- Веб-приложение внутри себя запускает мета-модель, к которому уже можно подключаться браузерами:
--- html (+ JavaScript) браузеры - тонкий клиент.

Архитектура
- Что-бы выделить мета-модель в сервер, нужно будет придумывать и авторизацию и аутентификацию для отдельных видов
  участников:
-- игрок,
-- наблюдатель,
-- администратор мета-моделей (что-бы уровни загружать).

Архитектура
- Варианты авторизации при подключении к серверу мета-модели:
-- только внутрення БД,
-- внешние варианты, прицепляемые к внутренней БД:
--- локальная ОС
--- доменная ОС
--- google и прочее.

Архитектура
Реализовать класс-контроллер - генерация команд в поток ввода команд.
- Реализовать класс-контроллер, который не будет привязан ни к символам клавиатуры (Scene), ни к кликам мыши (GameStackPane).
  Он должен быть привязан только к модели. Такой контроллер мог-бы стать, например,
  консолью ввода команд. Это типа поток ввода.
  Нужно подумать, на реакцию консоли на:
-- синтаксически не правильные команды,
-- правильные команды с различным откликом в модели:
--- нет изменений (например для Сапёра попытка открыть уже открытую ячейку),
--- нет изменений, т.к. не допустимая команда в контексте (например для Сапёра попытка открыть ячейку, на которой стоит флаг),
--- команда привела к изменению,
--- прочее.

Архитектура
Реализовать представление не графическое - чтение и вывод сообщений из потока вывода и потока вывода ошибок.
- Реализовать представление не графическое. Оно могло-бы выдавать информацию о принятом сообщении в текстовом виде.
  Это было-бы типа чтением из потока вывода и потока вывода ошибок.

MinesweeperModel и MineSweeperViewControlJfx (и др. GUI)
- В контроллере кликов мыши от Сапёра реализовать реакцию от средней кнопки мыши.

Архитектура
BaseModel
- В базовую модель внести возможность работать с играми в реальном режиме времени (Тетрис, Змейка).
-- Предусмотреть количество ходов, которое можно сделать за единицу времени.

Реализовать TetrisModel, TetrisViewControlJfx (и/или др. GUI)
- Реализовать тетрис.

Архитектура
Реализовать TileGameEngine... (где ... это хотя-бы ещё один из вариантов GTK+, AWT, SWT, Swing)
- В качестве альтернативных реализаций выборок и контроллеров, привязанных к графике в десктопном варианте,
  можно было-бы реализовать модули для хотя-бы ещё одного из вариантов:
-- GTK+,
-- AWT,
-- SWT,
-- Swing,
-- JavaFX - первично выбранная библиотека (на ней уже и реализованы первые версии).

Реализовать альтернативную реализацию GUI для одной игры ...ViewControl...
(где: 1-й ... - уже конкретная игра (Minesweeper, Sokoban), 2-й ... это GTK+, AWT, SWT, Swing)
- Например MinesweeperViewControlSwing.

Архитектура
BaseModel
- Внести в модель состояние о классификации игры. Это поможет для:
-- предоставлять или не предоставлять доступ к какому-то базовому функционалу (например для пошаговых игр не нужен таймер,
   или, может быть, не нужен будет доступ к генератору случайных чисел и т.п.),
-- требования по обязательности работы с каким-либо функционалом или требовать не работы с ним.
-- т.е. это будет сдерживать разработчиков от ошибок в реализациях:
--- либо на этапе компиляции (например через интерфейсы (как обязанность реализовать те или иные функции) и
    их реализации в конкретных моделях), что предпочтительнее.
--- либо во время игры, модель может попытаться обратиться к какому-либо функционалу, который ей не должен быть доступен.


30.09.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
- Создать web-приложение сервер, в котором уже сразу будет модель.
-- Клиентом должен стать HTML-JavaScript клиент

Архитектура
HTML-JavaScript клиент
- Создать интерактивный HTML-JavaScript клиент
-- Реализовать визуализацию:
   https://basecourse.ru/javascript/main.php
   Глава 4. События браузера
   Делегирование событий
   https://basecourse.ru/javascript/delegation.php
   JSTutorial
   basecourse.ru_javascript_main.php
   04090305.html
-- Реализовать отправку запросов из браузера на http-сервер
   https://basecourse.ru/ajax/main.php
-- Реализовать получение ответов от http-сервера
--- Вариант почти асинхронный:
    https://basecourse.ru/comet/main.php
--- https://learn.javascript.ru/
    Часть 2.
    Fetch
    XMLHttpRequest
    Сетевые запросы
    Длинные опросы
    WebSocket

Архитектура
- Создать web-приложение сервер, который будет подключаться клиентом к модели:
-- WebSocket...Model.
-- Клиентом должен стать HTML-JavaScript клиент.

Архитектура
MinesweeperModel и SokobanModel
- Модель в Сапёре разделена на MinesweeperModel и AllMinesweeperObjects, в Сокобане модель только в SokobanModel. Нужно
  проанализировать плюсы и минусы обоих вариантов и свести текущие варианты к одному:
-- Либо ...Model и All...Objects.
-- Либо только ...Model.

MinesweeperViewControlsJfx
- Баг (не красиво в визуализации): в MinesweeperPersistentSettings::update и в MinesweeperVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.

SokobanViewControlsJfx
- Баг (не красиво в визуализации): в SokobanPersistentSettings::update и в SokobanVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.


02.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
TileGameEngineJfx
- Сейчас имеются классы потомки ViewJfx, отвечающие за вывод целых значений (постоянных и переменных параметров
  статистики партии) и их потомки, которые могут принимать контроллер в конструкторе, чтобы работать с мышью.
  Но в этом нет необходимости.
  Нужно пересмотреть классы ViewJfx, ViewMainFieldJfx, ViewTextFieldsJfx чтобы каким-то классам предоставить возможность
  работы с мышью, а каким-то нет.
  Например, сделать это через интерфейс "Работа с мышью" и его реализацию в ViewMainFieldJfx или в новом промежуточном
  классе между ViewJfx и ViewMainFieldJfx.


07.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Для того, что-бы модуль "всё в одном" мог и дальше работать (но, как писал ранее, только для одного игрока),
  действия с п. 2 по п. 6 нужно выделить в отдельный модуль. Создать интерфейс/интерфейсы для модели и выборки.
  И сделать несколько реализаций, в т.ч.:
-- очень простая для работы "всё в одном",
-- для работы в сети.


10.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Ввести сущность "роль игрового объекта". Например в Го - это камень, в Шашках - это шашка и дамка, а уж в Шахматах
  и того более... (Также см. заметки) Она будет нести и описательную роль и функциональную.
  Причём роль для отдельных игр может:
-- либо не меняться в течение игры (Го).
-- либо в процессе игры поменяться при определённых обстоятельствах (Шашки, Шахматы).

BaseModel
- BaseModel сделать интерфейсом. В нём продекларировать те же методы, что сейчас у BaseModel.
  Такой подход уменьшит количество переименований по всем пакетам - модулям проекта.
-- Отдельный NetModel, реализующий новый BaseModel, будет для работы выборок и контроллеров с моделями через сеть.


23.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel, WebSocketServer, WebSocketClient
- Сейчас в BaseModel в исходящую очередь добавляются сообщения, а при вызове notify вызываются update, каждой
  присоединённой view. Такое подходит, когда модель и выборка в одном исполняемом коде.
  Отказываемся от очередей.
  Для сетевого взаимодействия нужно разделить функционал на MVC
  (М - модель (сервер), В - выборка (клиент), К - контроллер (клиент)):
-- Инициатор - К:
--- 1. К: запрос информации или отправление команды в Модель,
--- 2. М: приём по сети сообщений в основном потоке WebSocket сервера.
          Передача в поток отдельной модели.
-- Инициатор - М:
--- 1. М: Когда в Модели происходят изменения, отправляем сообщения всем выборкам, присоединённым к данной модели
          (и желательно подписанных на определённый тип сообщений).
--- 2. В: приём в основном потоке WebSocket клиента (каждого, кто подключен к определённой модели).
          Передача сообщения в JavaFX поток в каждую выборку (на тип сообщений которые подписано).
          Выборка себя обновляет.

Архитектура
- Реализовать простой WebSocketServer и WebSocketClient. В которых реализовать протокол взаимодействия между клиентом и
  сервером.
-- Каждое из типов сообщений сервера так или иначе делается в ответ на запрос клиента.
-- Для WebSocketClient предложить и реализовать взаимодействие со своими собственными контроллерами и выборками в
   асинхронном режиме.


30.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- В текущем варианте модель сообщает выборкам не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Сейчас лог в подобном формате ведётся только для Сокобан. Но его можно было-бы сделать более универсальным.
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

BaseModel
- Изменить порядок регистрации выборки в модели и порядок извещения моделью выборок:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна отправлять сообщения в выборки, на которые были подписки. Если есть событие,
   на которое не было подписки - оно никому не направляется.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.

MultiGameWebSocketClient, MultiGameWebSocketServer, GameClients
- Когда пользователь постепенно переходит:
-- от не соединённого состояния с сервером к соединённому и наоборот,
-- от не идентифицированного пользователя к авторизованному и наоборот,
-- и т.д. "продвигаясь" к игре партии и в обратную сторону.
  Нужно:
-- Накапливать данные о состоянии (например ч/з Optional) по пути к игре и стирать данные о состоянии в обратном порядке.
-- При вызове методов проверять, допустимо-ли вызывать определённый метод в текущем состоянии.
   Если не допустимо - создавать исключение.
-- Обеспечить механизм работы с контролами JavaFX
--- Со стороны контролов:
---- Присоединение к MultiGameWebSocketClient.
     Кнопки и поля ввода, которые можно пока для простоты объединить в готовые к применению классы
     из нескольких контролов под различные состояния), например:
----- 1. ТекстПоле сервер, ТекстПоле порт, Кнопка коннект, Кнопка дисконнект.
----- 2. ТекстПоле имяПользователя, ПарольТекстПоле пароль, Кнопка войти, Кнопка выйти.
         (где-то здесь и регистрацию нового пользователя потом влепить).
----- 3. Список типИгры, Кнопка выбрать, Кнопка назад.
----- ...
     В т.ч. настройка умолчательного поведения
     (т.е. при нажатии на кнопку, которая присоединена к методу login, должна вызываться login без дополнительной
     настройки кода. Это можно делать при объединении контролов в блоки).
     И в т.ч. при поступлении об изменении состояния MultiGameWebSocketClient делать доступным либо не доступным
     отдельные контролы.
--- Со стороны MultiGameWebSocketClient:
---- Запоминание присоединенных контролов к MultiGameWebSocketClient (например при создании группового контрола),
---- доступность контролов (setDisable) должна также регулироваться состоянием MultiGameWebSocketClient
     (к-рое в свою очередь изменяется при поступлении того или иного сообщения от сервера).