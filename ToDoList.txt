27.09.2023

- Написать бизнес-требования на текущую работающую версию.

- Написать ТЗ на текущую работающую версию.

BaseModel
- Классы Tile, Direction, DxDy назовём группа 1.
  BaseModel, View, [ ObservableModel, ViewInterface, ViewMainArea] назовём группа 2 (BaseModel).
  Группа 1 и 2 сейчас не связаны.
  Вероятно нужно:
-- Либо разделить на разные модули;
-- Либо BaseModel должна зависеть от Tile.

- Группа 1 сейчас может работать с перемещением относительно ячейки, но:
-- Не всем играм и нужны перемещения (например Сапёр);
-- Возможно перемещение привязать к независимо-перемещающемуся объекту (ведь в Сокобане ящик перемещается не сам,
   а потому, что его толкает игрок);
--- Перемещение вообще может быть групповым и однонаправленным (например Space Invaders - там инопланетные корабли (
    каждый из которых уже не одноячеечный объект) перемещаются синхронно влево-вправо-вниз, а вот Tetris - там падает
    одна 4-х ячеечная фигурка - это не группа объектов).

- Нужно предоставить возможность отдельному контроллеру запрашивать состояние чего-либо в игре (ячейки, объекта,
  времени, состояния) и при этом только для него и писать такие сообщения.

Архитектура
Вероятно отдельный модуль Интернационализации
- Внедрить мультиязычность для:
-- текстовых выборок (поток вывода и поток вывода ошибок),
-- подписей к контролерам и выборкам,
-- контроллеров-интерпретаторов команд,
-- тул-типов,
-- для меню,
-- и всего прочего.

Примеры реализации View (как JFX, так и в других GUI)
- Варианты игрового поля для различных игр, могут иметь различия в отображении главного поля, например:
-- шахматная раскраска,
-- для игры Го камни ставятся на перекрестие,
-- для игры в нарды в модели поле может быть 2 х 12, а вот изображать его - нужно подумать.

Архитектура
Абстрактная визуализации
- Сделать отдельный модуль, отвечающий за абстрактную визуализацию, в который вывести общее для любых графических
  библиотек (и даже для JavaScript), например:
-- символы, цвета, картинки, размеры, стили.
-- анимацию?

- Реализовать легенду (надписи о координатах ячеек) слева, справа, сверху, снизу (все четыре должны быть необязательные).
-- В т.ч. с различными вариантами символов (цифры, буквы различного алфавита (UP/low), произвольный перечень слов).
-- На ячейках, где легенда, не должно быть реакции от мыши.

Архитектура
Мета-модель
- Ввести понятие мета-модель, которое должно:
-- вести игру между уровнями (там могут быть различные планы уровней и прочее).
--- в т.ч. задавать ширину / высоту и прочие параметры для отдельной партии.

Архитектура
?
- После введения мета-модели ввести в различные варианты визуализации (JavaFX, JavaScript) меню игры,
  в которой видеть и/или редактировать можно будет параметры мета-модели.

BaseModel
- У морского боя два поля - по одному у каждого игрока. Это как-то не укладывается в текущую модель. Варианты:
-- Игрок либо может играть с одним полем, которое в модели (общее поле),
-- Либо игрок имеет своё поле, которое принадлежит только ему (частное поле).

Архитектура
В разных модулях реализовывать сборки "всё в одном" и части системы для клиент-серверных вариантов.
- Можно создать несколько видов компоновки и запуска приложений:
-- "всё в одном" - уже реализовано. Но не для всех видов игр подойдёт (например Морской бой).
-- Для модели, а потом и мета-модели, сделать отдельный вид запуска как TCP-сервер. Тогда клиенты могут подключаться как:
--- толстыми клиентами:
---- десктоп-приложение - различных ПК Windows (JavaFX), (а может и Linux),
---- Android,
---- iOS,
---- Web-сервер, к которому уже можно подключаться браузерами, см. ниже:
-- Веб-приложение внутри себя запускает модель, а потом и мета-модель, к которому уже можно подключаться браузерами:
----- html (+ JavaScript) браузеры - тонкий клиент.

Архитектура
- Что-бы выделить модель в сервер, нужно будет придумывать и авторизацию и идентификацию для отдельных видов участников:
-- игрокам,
-- наблюдателям,
-- администраторам мета-моделей (что-бы уровни загружать).

Архитектура
- Варианты идентификации при подключении к серверу мета-модели:
-- только внутрення БД,
-- внешние варианты, прицепляемые к внутренней БД:
--- локальная ОС
--- доменная ОС
--- google и прочее.

Архитектура
BaseModel
- Текущий вариант очереди сообщений содержит в себе не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

BaseModel
- В модели очередь сообщений сначала очень упростить в реализации.

BaseModel
- Очередь сообщений изменить:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна писать в одну очередь все события, на которые были подписки. Если есть событие,
   на которое не было подписки - оно не пишется в очередь.
-- Чтение из очереди отдельно взятой выборкой не должно приводить к удалению прочтённого сообщения.
   Но где-то в очереди нужно фиксировать, что такая-то выборка прочитала последнее такое-то сообщение.
-- Удаление сообщения из очереди должно происходить тогда, когда сообщение было прочитано всеми выборками.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.

BaseModel
- Дополнить модель очередью команд. Именно в эту очередь должны писать контроллеры.

Архитектура
Реализовать класс-контроллер - генерация команд в поток ввода команд.
- Реализовать класс-контроллер, который не будет привязан ни к символам клавиатуры (Scene), ни к кликам мыши (GameStackPane).
  Он должен быть привязан только к модели, или, ещё лучше, к очереди команд. Такой контроллер мог-бы стать, например,
  консолью ввода команд. Это типа поток ввода.
  Нужно подумать, на реакцию консоли на:
-- синтаксически не правильные команды,
-- правильные команды с различным откликом в модели:
--- нет изменений (например для Сапёра попытка открыть уже открытую ячейку),
--- нет изменений, т.к. не допустимая команда в контексте (например для Сапёра попытка открыть ячейку, на которой стоит флаг),
--- команда привела к изменению,
--- прочее.

Архитектура
Реализовать представление не графическое - чтение и вывод сообщений из потока вывода и потока вывода ошибок.
- Реализовать представление не графическое. Оно могло-бы выдавать информацию о принятом сообщении в текстовом виде.
  Это было-бы типа чтением из потока вывода и потока вывода ошибок.

MinesweeperModel и MineSweeperViewControlJfx (и др. GUI)
- В контроллере кликов мыши от Сапёра реализовать реакцию от средней кнопки мыши.

Архитектура
BaseModel
- В базовую модель внести возможность работать с играми в реальном режиме времени (тетрис, змейка).
-- Предусмотреть количество ходов, которое можно сделать за единицу времени.

Реализовать TetrisModel, TetrisViewControlJfx (и/или др. GUI)
- Реализовать тетрис.

Реализовать TileGameEngine... (где ... это GTK+, AWT, SWT, Swing)
- В качестве альтернативных реализаций выборок и контроллеров, привязанных к графике в десктопном варианте,
  можно было-бы реализовать модули для хотя-бы ещё одного из вариантов:
-- GTK+,
-- AWT,
-- SWT,
-- Swing,
-- JavaFX - первично выбранная библиотека (на ней и реализованы первые версии).

Реализовать альтернативную реализацию GUI для одной игры ...ViewControl...
(где: 1-й ... - уже конкретная игра (Minesweeper, Sokoban), 2-й ... это GTK+, AWT, SWT, Swing)
- Например MinesweeperViewControlSwing.

Архитектура
BaseModel
- Внести в модель состояние о классификации игры. Это поможет для:
-- предоставлять или не предоставлять доступ к какому-то базовому функционалу (например для пошаговых игр не нужен таймер,
   или, может быть, не нужен будет доступ к генератору случайных чисел и т.п.),
-- требования по обязательности работы с каким-либо функционалом или требовать не работы с ним.
-- т.е. это будет сдерживать разработчиков от ошибок в реализациях:
--- либо на этапе компиляции (например через интерфейсы (как обязанность реализовать те или иные функции) и
    их реализации в конкретных моделях), что предпочтительнее.
--- либо во время игры, модель может попытаться обратиться к какому-либо функционалу, который ей не должен быть доступен.


30.09.2023

Архитектура
- Выбрать WebSocket и Server Sent Events как технологии по оперативному обмену событиями между участниками соединения,
  а может вообще что-то другое:
-- Изучить в теории (в т.ч. плюсы и минусы),
-- Отдельно собрать простые примеры,
-- Выбрать один из них.

Архитектура
(WebSocketModel или ServerSentEventsModel) и (WebViewControlJfx или ServerSentEventsControlJfx)
- Создать отдельные модули по запуску только модели и только клиента:
-- Оба модуля вероятно с использованием WebSocket или Server Sent Events.
-- Вероятно конкретные названия модулей будут:
--- WebSocket...Model или ServerSentEvents...Model.
--- WebViewControl...Jfx или ServerSentEventsControl...Jfx.

Архитектура
- Создать web-приложение сервер, в котором уже сразу будет модель.
-- Клиентом должен стать HTML-JavaScript клиент

Архитектура
HTML-JavaScript клиент
- Создать интерактивный HTML-JavaScript клиент
-- Реализовать визуализацию:
   https://basecourse.ru/javascript/main.php
   Глава 4. События браузера
   Делегирование событий
   https://basecourse.ru/javascript/delegation.php
   JSTutorial
   basecourse.ru_javascript_main.php
   04090305.html
-- Реализовать отправку запросов из браузера на http-сервер
   https://basecourse.ru/ajax/main.php
-- Реализовать получение ответов от http-сервера
--- Вариант почти асинхронный:
    https://basecourse.ru/comet/main.php
--- https://learn.javascript.ru/
    Часть 2.
    Fetch
    XMLHttpRequest
    Сетевые запросы
    Длинные опросы
    WebSocket
    Server Sent Events

Архитектура
- Создать web-приложение сервер, который будет подключаться клиентом к модели:
-- WebSocket...Model или ServerSentEvents...Model.
-- Клиентом должен стать HTML-JavaScript клиент.

MinesweeperModel и SokobanModel
- Модель в Сапёре разделена на MinesweeperModel и AllMinesweeperObjects, в Сокобане модель только в SokobanModel. Нужно
  проанализировать плюсы и минусы обоих вариантов и свести текущие варианты к одному:
-- Либо ...Model и All...Objects.
-- Либо только ...Model.

MinesweeperViewControlsJfx и SokobanViewControlsJfx
- Классы MinesweeperPersistentSettings, MinesweeperVariableSettings, SokobanPersistentSettings, SokobanVariableSettings
  очень похожи. Их нужно унифицировать и общее вывести в верхний класс. Учесть не только один параметр, а более параметров.

SokobanModel
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanModel.
-- GameEventSokobanPersistentParams.
-- GameEventSokobanVariableParams.

SokobanViewControlsJfx
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanPersistentSettings.
-- SokobanVariableSettings.

MinesweeperViewControlsJfx
- Есть баг в MinesweeperPersistentSettings::update и в MinesweeperVariableSettings::update. Лишние переносы строки. Т.е.
  если их сейчас убрать, то текст будет залазить на более верхний объект. Разобраться и исправить.

SokobanViewControlsJfx
- Есть баг в SokobanPersistentSettings::update и в SokobanVariableSettings::update. Лишние переносы строки. Т.е.
  если их сейчас убрать, то текст будет залазить на более верхний объект. Разобраться и исправить.
