27.09.2023 ------------------------------------------------------------------------------------------------------------

- Написать бизнес-требования на текущую работающую версию.

- Написать ТЗ на текущую работающую версию.

BaseModel
- Классы Tile, Direction, DxDy назовём группа 1.
  BaseModel, View, [ ObservableModel, ViewInterface, ViewMainArea] назовём группа 2 (BaseModel).
  Группа 1 и 2 сейчас не связаны.
  Вероятно нужно:
-- Либо разделить на разные модули;
-- Либо BaseModel должна зависеть от Tile.

- Группа 1 сейчас может работать с перемещением относительно ячейки, но:
-- Не всем играм и нужны перемещения (например Сапёр);
-- Возможно перемещение привязать к независимо-перемещающемуся объекту (ведь в Сокобане ящик перемещается не сам,
   а потому, что его толкает игрок);
--- Перемещение вообще может быть групповым и однонаправленным (например Space Invaders - там инопланетные корабли (
    каждый из которых уже не одноячеечный объект) перемещаются синхронно влево-вправо-вниз, а вот Tetris - там падает
    одна 4-х ячеечная фигурка - это не группа объектов).

- Нужно предоставить возможность отдельному контроллеру запрашивать состояние чего-либо в игре (ячейки, объекта,
  времени, состояния) и при этом только для него и писать такие сообщения.

Архитектура
Вероятно отдельный модуль Интернационализации
- Внедрить мультиязычность для:
-- текстовых выборок (поток вывода и поток вывода ошибок),
-- подписей к контролерам и выборкам,
-- контроллеров-интерпретаторов команд,
-- тул-типов,
-- для меню,
-- и всего прочего.

Примеры реализации View (как JFX, так и в других GUI)
- Варианты игрового поля для различных игр, могут иметь различия в отображении главного поля, например:
-- шахматная раскраска,
-- для игры Го камни ставятся на перекрестие,
-- для игры в нарды в модели поле может быть 2 х 12, а вот изображать его - нужно подумать.

Архитектура
Абстрактная визуализации
- Сделать отдельный модуль, отвечающий за абстрактную визуализацию, в который вывести общее для любых графических
  библиотек (и даже для JavaScript), например:
-- символы, цвета, картинки, размеры, стили.
-- анимацию?

- Реализовать легенду (надписи о координатах ячеек) слева, справа, сверху, снизу (все четыре должны быть необязательные).
-- В т.ч. с различными вариантами символов (цифры, буквы различного алфавита (UP/low), произвольный перечень слов).
-- На ячейках, где легенда, не должно быть реакции от мыши.

Архитектура
Мета-модель
- Ввести понятие мета-модель, которое должно:
-- вести игру между уровнями (там могут быть различные планы уровней и прочее).
--- в т.ч. задавать ширину / высоту и прочие параметры для отдельной партии.

Архитектура
?
- После введения мета-модели ввести в различные варианты визуализации (JavaFX, JavaScript) меню игры,
  в которой видеть и/или редактировать можно будет параметры мета-модели.

BaseModel
- У Морского боя два поля - по одному у каждого игрока. Это как-то не укладывается в текущую модель. Варианты:
-- Игрок либо может играть только с одним полем, которое в модели (общее поле) (т.е. игнорировать Морской бой с его
   своими полями для каждого игрока),
-- Либо в модель ввести перечисление с такими вариантами:
--- в игре только одно поле - общее (для почти всех игр, кроме Морского боя).
--- каждый игрок имеет своё поле, которое принадлежит только ему (частное поле) и нет общего поля (для Морского боя).
--- комбинация, т.е. есть и одно общее поле и два частных поля (пример игры в голову не приходит).

Архитектура
В разных модулях реализовывать сборки "всё в одном" и части системы для клиент-серверных вариантов.
- Можно создать несколько видов компоновки и запуска приложений:
-- "всё в одном" - уже реализовано. Но подойдёт он только для игр с одним игроком (Тетрис, Змейка, Сапер).
-- Для мета-модели, сделать отдельный вид запуска как WebSocket-сервер. Тогда клиенты могут подключаться как:
--- толстыми клиентами (как WebSocket клиенты):
---- десктоп-приложение - различных ПК Windows (JavaFX), (а может и Linux),
---- Android,
---- iOS,
---- Web-сервер, к которому уже можно подключаться браузерами, см. ниже:
-- Веб-приложение внутри себя запускает мета-модель, к которому уже можно подключаться браузерами:
--- html (+ JavaScript) браузеры - тонкий клиент.

Архитектура
- Что-бы выделить мета-модель в сервер, нужно будет придумывать и авторизацию и аутентификацию для отдельных видов
  участников:
-- игрок,
-- наблюдатель,
-- администратор мета-моделей (что-бы уровни загружать).

Архитектура
- Варианты авторизации при подключении к серверу мета-модели:
-- только внутрення БД,
-- внешние варианты, прицепляемые к внутренней БД:
--- локальная ОС
--- доменная ОС
--- google и прочее.

Архитектура
BaseModel
- Текущий вариант очереди сообщений содержит в себе не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

BaseModel
- Очередь сообщений изменить:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна писать в одну очередь все события, на которые были подписки. Если есть событие,
   на которое не было подписки - оно не пишется в очередь.
-- Чтение из очереди отдельно взятой выборкой не должно приводить к удалению прочтённого сообщения.
   Но где-то в очереди нужно фиксировать, что такая-то выборка прочитала последнее такое-то сообщение.
-- Удаление сообщения из очереди должно происходить тогда, когда сообщение было прочитано всеми выборками.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.

BaseModel
- Дополнить модель очередью команд. Именно в эту очередь должны писать контроллеры.

Архитектура
Реализовать класс-контроллер - генерация команд в поток ввода команд.
- Реализовать класс-контроллер, который не будет привязан ни к символам клавиатуры (Scene), ни к кликам мыши (GameStackPane).
  Он должен быть привязан только к модели, или, ещё лучше, к очереди команд. Такой контроллер мог-бы стать, например,
  консолью ввода команд. Это типа поток ввода.
  Нужно подумать, на реакцию консоли на:
-- синтаксически не правильные команды,
-- правильные команды с различным откликом в модели:
--- нет изменений (например для Сапёра попытка открыть уже открытую ячейку),
--- нет изменений, т.к. не допустимая команда в контексте (например для Сапёра попытка открыть ячейку, на которой стоит флаг),
--- команда привела к изменению,
--- прочее.

Архитектура
Реализовать представление не графическое - чтение и вывод сообщений из потока вывода и потока вывода ошибок.
- Реализовать представление не графическое. Оно могло-бы выдавать информацию о принятом сообщении в текстовом виде.
  Это было-бы типа чтением из потока вывода и потока вывода ошибок.

MinesweeperModel и MineSweeperViewControlJfx (и др. GUI)
- В контроллере кликов мыши от Сапёра реализовать реакцию от средней кнопки мыши.

Архитектура
BaseModel
- В базовую модель внести возможность работать с играми в реальном режиме времени (Тетрис, Змейка).
-- Предусмотреть количество ходов, которое можно сделать за единицу времени.

Реализовать TetrisModel, TetrisViewControlJfx (и/или др. GUI)
- Реализовать тетрис.

Архитектура
Реализовать TileGameEngine... (где ... это хотя-бы ещё один из вариантов GTK+, AWT, SWT, Swing)
- В качестве альтернативных реализаций выборок и контроллеров, привязанных к графике в десктопном варианте,
  можно было-бы реализовать модули для хотя-бы ещё одного из вариантов:
-- GTK+,
-- AWT,
-- SWT,
-- Swing,
-- JavaFX - первично выбранная библиотека (на ней уже и реализованы первые версии).

Реализовать альтернативную реализацию GUI для одной игры ...ViewControl...
(где: 1-й ... - уже конкретная игра (Minesweeper, Sokoban), 2-й ... это GTK+, AWT, SWT, Swing)
- Например MinesweeperViewControlSwing.

Архитектура
BaseModel
- Внести в модель состояние о классификации игры. Это поможет для:
-- предоставлять или не предоставлять доступ к какому-то базовому функционалу (например для пошаговых игр не нужен таймер,
   или, может быть, не нужен будет доступ к генератору случайных чисел и т.п.),
-- требования по обязательности работы с каким-либо функционалом или требовать не работы с ним.
-- т.е. это будет сдерживать разработчиков от ошибок в реализациях:
--- либо на этапе компиляции (например через интерфейсы (как обязанность реализовать те или иные функции) и
    их реализации в конкретных моделях), что предпочтительнее.
--- либо во время игры, модель может попытаться обратиться к какому-либо функционалу, который ей не должен быть доступен.


30.09.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
WebSocketModel и WebViewControlJfx
- Создать отдельные модули по запуску только модели и только клиента:
-- Оба модуля с использованием WebSocket.
-- Вероятно конкретные названия модулей будут:
--- WebSocket...Model.
--- WebViewControl...Jfx.

Архитектура
- Создать web-приложение сервер, в котором уже сразу будет модель.
-- Клиентом должен стать HTML-JavaScript клиент

Архитектура
HTML-JavaScript клиент
- Создать интерактивный HTML-JavaScript клиент
-- Реализовать визуализацию:
   https://basecourse.ru/javascript/main.php
   Глава 4. События браузера
   Делегирование событий
   https://basecourse.ru/javascript/delegation.php
   JSTutorial
   basecourse.ru_javascript_main.php
   04090305.html
-- Реализовать отправку запросов из браузера на http-сервер
   https://basecourse.ru/ajax/main.php
-- Реализовать получение ответов от http-сервера
--- Вариант почти асинхронный:
    https://basecourse.ru/comet/main.php
--- https://learn.javascript.ru/
    Часть 2.
    Fetch
    XMLHttpRequest
    Сетевые запросы
    Длинные опросы
    WebSocket

Архитектура
- Создать web-приложение сервер, который будет подключаться клиентом к модели:
-- WebSocket...Model.
-- Клиентом должен стать HTML-JavaScript клиент.

Архитектура
MinesweeperModel и SokobanModel
- Модель в Сапёре разделена на MinesweeperModel и AllMinesweeperObjects, в Сокобане модель только в SokobanModel. Нужно
  проанализировать плюсы и минусы обоих вариантов и свести текущие варианты к одному:
-- Либо ...Model и All...Objects.
-- Либо только ...Model.

MinesweeperViewControlsJfx
- Баг (не красиво в визуализации): в MinesweeperPersistentSettings::update и в MinesweeperVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.

SokobanViewControlsJfx
- Баг (не красиво в визуализации): в SokobanPersistentSettings::update и в SokobanVariableSettings::update.
  Лишние переносы строки. Т.е. если их сейчас убрать, то текст будет залазить на более верхний объект.
  Разобраться и исправить.


02.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
TileGameEngineJfx
- Сейчас имеются классы потомки ViewJfx, отвечающие за вывод целых значений (постоянных и переменных параметров
  статистики партии) и их потомки, которые могут принимать контроллер в конструкторе, чтобы работать с мышью.
  Но в этом нет необходимости.
  Нужно пересмотреть классы ViewJfx, ViewMainFieldJfx, ViewTextFieldsJfx чтобы каким-то классам предоставить возможность
  работы с мышью, а каким-то нет.
  Например, сделать это через интерфейс "Работа с мышью" и его реализацию в ViewMainFieldJfx или в новом промежуточном
  классе между ViewJfx и ViewMainFieldJfx.


07.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Сейчас в BaseModel в исходящую очередь добавляются сообщения, а при вызове notify вызываются update, каждой
  присоединённой view. Такое подходит, когда модель и выборка в одном исполняемом коде.
  Для сетевого взаимодействия нужно разделить функционал на:
-- 1. М: внесению сообщений от модели в очередь модели,
-- 2. М: передача по сети сообщений из очереди модели,
-- 3. В: приём по сети сообщений в выборке,
-- 4. В: внесение в очередь входящих сообщений на стороне выборки,
-- 5. В: известить модель (дать отклик), что сообщение получено,
-- 6. М: если модель получила отклик, что сообщение получено выборкой, то удалить его из своей очереди,
-- 7. В: вызов update на стороне выборки,
-- 8. В: удаление сообщения из очереди выборки.

Архитектура
BaseModel
- Для того, что-бы модуль "всё в одном" мог и дальше работать (но, как писал ранее, только для одного игрока),
  действия с п. 2 по п. 6 нужно выделить в отдельный модуль. Создать интерфейс/интерфейсы для модели и выборки.
  И сделать несколько реализаций, в т.ч.:
-- очень простая для работы "всё в одном",
-- для работы в сети.

Сценарий
Запуск клиента игр, подключение к серверу, авторизация, выбор типа игры, подключение или создание игры, запуск.
- После запуска клиента игры должно происходить:
1. ввод адреса сервера (и порта),
2. команда на подключение
3. регистрация / авторизация:
3.1. либо регистрация и потом всё равно авторизация,
3.2. либо авторизация (ввод имени и пароля, либо альтернативная авторизация ч/з серверы авторизации),
4. Сервер аутентифицирует авторизованного пользователя (далее будем считать его либо игроком, либо наблюдателем),
5. Сервер показывает перечень игр (т.е. зарегистрированных в нём макромоделей),
6. Клиент выбирает игру (макромодель),
7. Сервер показывает перечень открытых для входа этому игроку типов игр:
7.1. для игр с одним игроком:
7.1.1. новая игра,
7.1.2. продолжить ранее игранную и сохранённую игру,
7.2. для игр с двумя игроками (и м.б. более):
7.2.1. новая игра:
7.2.1.1. игрок может указать логин (или несколько) с кем он готов сыграть.
7.2.1.2. либо будет предполагаться, что игрок может быть любой.
7.2.2. продолжить ранее игранную и сохранённую игру:
7.2.2.1. для реал-тайм все оппоненты должны быть готовы к игре перед запуском,
7.2.2.2. для пошаговой если будет ход игрока, то он сможет ходить.
7.2.3. присоединиться к открытой игре каким-то другим игроком
7.2.3.1. либо для этого игрока (он мог быть один, а мог быть в перечне),
7.2.3.2. либо публичную.
8. Запуск / подключение к новой или запуск / подключение к ранее сохранённой игре (партии).
9. Игра партии.

Архитектура
- Создать отдельный модуль с данными для авторизации: имя / пароль, и парой готовых записей.


10.10.2023 ------------------------------------------------------------------------------------------------------------

Архитектура
BaseModel
- Ввести сущность "роль игрового объекта". Например в Го - это камень, в Шашках - это шашка и дамка, а уж в Шахматах
  и того более... (Также см. заметки) Она будет нести и описательную роль и функциональную.
  Причём роль для отдельных игр может:
-- либо не меняться в течение игры (Го).
-- либо в процессе игры поменяться при определённых обстоятельствах (Шашки, Шахматы).

BaseModel, ...View
- Сейчас очереди сообщений (от модели к выборкам) находятся в модели (т.к. реализована сборка типа "всё-в-одном").
  Для последующей реализации других вариантов сборки нужно создать свои экземпляры очередей в каждой из выборок.
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очереди в модели в очереди в выборки.

BaseModel, ...Controller
- Кроме того, что в модели должна появиться очередь команд, в каждом из контроллеров должна также появиться своя очередь
  команд
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очередей в контроллерах в очередь в модели.

View, ViewJfx (и наследники)
- Класс View сейчас не используется, но там есть базовый функционал. Нужно отрефакторить ViewJfx, что-бы было использование.

BaseModel
- BaseModel сделать интерфейсом. В нём продекларировать те же методы, что сейчас у BaseModel.
  Такой подход уменьшит количество переименований по всем пакетам - модулям проекта.
-- Текущий BaseModel сделать LocalBaseModel, реализующий новый BaseModel.
-- Отдельный NetBaseModel, реализующий новый BaseModel, будет для работы выборок и контроллеров с моделями через сеть.
