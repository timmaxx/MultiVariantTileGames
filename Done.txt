01.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
MinesweeperModel
- Класс GameEventMinesweeperVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- GameEventMinesweeperVariableParams.
-- AllMinesweeperObjects.

(30.09.2023)
MinesweeperViewControlsJfx
- Класс GameEventMinesweeperVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- MinesweeperVariableSettings.

(30.09.2023)
SokobanModel
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanModel.
-- GameEventSokobanVariableParams.

(30.09.2023)
SokobanViewControlsJfx
- Класс GameEventSokobanVariableParams отвечает за несколько разных событий. Разделить. Это повлияет на:
-- SokobanVariableSettings.


02.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
Архитектура
TileGameEngineJfx
- Подготовить модуль для унификации классов потомков ViewJfx, отвечающих за вывод целых значений
  (постоянных и переменных параметров статистики партии) и их потомков в связи с их похожестью:
-- MinesweeperPersistentSettings, MinesweeperVariableSettings,
-- SokobanPersistentSettings, SokobanVariableSettings.

(30.09.2023)
Архитектура
MinesweeperViewControlsJfx
- Классы MinesweeperPersistentSettings, MinesweeperVariableSettings и их потомки очень похожи.
-- Их нужно унифицировать и общее вывести в новый родительский класс.

(30.09.2023)
Архитектура
SokobanViewControlsJfx
- SokobanPersistentSettings, SokobanVariableSettings и их потомки очень похожи.
-- Их нужно унифицировать и общее вывести в новый родительский класс.


05.10.2023 ------------------------------------------------------------------------------------------------------------

(30.09.2023)
Архитектура
TileGameEngineJfx
- Подготовить модуль для унификации классов потомков ViewJfx, отвечающих за вывод целых значений
  (постоянных и переменных параметров статистики партии) и их потомков в связи с их работой более чем с одним полем вывода:
-- MinesweeperPersistentSettings, MinesweeperVariableSettings,
-- SokobanPersistentSettings, SokobanVariableSettings.

(30.09.2023) В коммите есть попытка реализации в BaseModel. Неуспешная. Будет удалена. Отказ от реализации.
Архитектура
BaseModel и наследники (MinesweeperModel и SokobanModel)
- Класс GameEventROTextFields пустой (в BaseModel) и его наследники GameEventMinesweeper... (в MinesweeperModel
  не могут при наследовании иметь независимую static переменную.
  Эта задача похоже связана с задачей от 30.09.2023 "Подготовить модуль для унификации классов потомков ViewJfx,
  отвечающих за вывод целых значений (постоянных и переменных параметров статистики партии) и их потомков в связи с их
  работой более чем с одним полем вывода".
  Нужно найти более правильное архитектурное решение. Вероятно оно будет связано с введением в базовый класс списка
  параметров для вывода в выборку, где элементом списка было-бы: заголовок, тип, значение.
-- Причем сейчас тип только int, а ведь возможно там и другой тип может быть, например текст или Enum.
-- Даже при этом универсальном виде заголовок и тип - значения всегда одинаковые в списке для отдельно взятого типа
   сообщения.

(05.10.2023)
Архитектура
MinesweeperModel и MinesweeperViewControlsJfx
- Удалить константы из кода функций Minesweeper...Settings... и перенести их в классы:
-- либо GameEventMinesweeper...,
-- либо преобразовать в другое архитектурное решение (см. следующую задачу).

(30.09.2023) Отказ от реализации.
Архитектура
MinesweeperViewControlsJfx
- Классы MinesweeperPersistentSettings, MinesweeperVariableSettings и их потомки очень похожи.
-- После первой унификации учесть не только один параметр, а унифицировать для более чем одного параметра.

(05.10.2023)
Архитектура
SokobanModel и SokobanViewControlsJfx
- Удалить константы из кода функций Sokoban...Settings... и перенести их в классы:
-- либо GameEventSokoban...,
-- либо преобразовать в другое архитектурное решение (см. следующую задачу).

(30.09.2023) Отказ от реализации.
Архитектура
SokobanViewControlsJfx
- SokobanPersistentSettings, SokobanVariableSettings и их потомки очень похожи.
-- После первой унификации учесть не только один параметр, а унифицировать для более чем одного параметра.


07.10.2023 ------------------------------------------------------------------------------------------------------------

(27.09.2023)
BaseModel
- В модели очередь сообщений сначала очень упростить в реализации.

(30.09.2023) - Частично. Т.е. не реализовывал Server Sent Events. Выбран WebSocket.
Найдена библиотека Java-WebSocket. И из примеров сначала повторен чат-сервер и чат-клиенты, а потом ещё и отрефакторены
  и унифицировано поведение для чат-клиентов со Swing и с Console-интерфейсами.
Архитектура
- Выбрать WebSocket и Server Sent Events как технологии по оперативному обмену событиями между участниками соединения,
  а может вообще что-то другое:
-- Изучить в теории (в т.ч. плюсы и минусы),
-- Отдельно собрать простые примеры,
-- Выбрать один из них.


09.10.2023 ------------------------------------------------------------------------------------------------------------

(09.10.2023) - почти, т.к. timmax.tilegame.game.minesweeper.server и client ещё не реализованы
Архитектура
Все модули
- Переделать структуру и имена пакетов:
  timmax.tilegame - корень всего многомодульного проекта
-- Модуль BaseTileModel - базовая абстрактная модель и выборки:
--- timmax.tilegame.basemodel
--- timmax.tilegame.baseview
-- Модуль BaseGameEngineJFX - движок для отрисовки в десктопном варианте на JavaFX:
--- timmax.tilegame.guiengine
---- timmax.tilegame.guiengine.swing - такого пакета сейчас нет, но если-бы он появился,
     то его нужно делать в другом модуле, но с этим именем.
---- timmax.tilegame.guiengine.jfx - корень модуля для реализации JavaFX движка
----- timmax.tilegame.guiengine.jfx.view - типовые выборки
----- timmax.tilegame.guiengine.jfx.controller - типовые контроллеры
-- timmax.tilegame.game - пакет, в котором уже будут реализованы конкретные виды игр.
   В отдельных пакетах и модулях модель игры, в отдельных выборки и контроллеры, в отдельных сборка запускаемых вариантов.
   Например:
-- Модуль MinesweeperModel - реализует модель игры Сапёр
--- timmax.tilegame.game.minesweeper.model
-- Модуль MinesweeperViewControlJFX - реализует визуализацию и приём команд от мыши и клавиатуры для игры Сапёр на JavaFX
--- timmax.tilegame.game.minesweeper.jfx
--- timmax.tilegame.game.minesweeper.jfx.view - выборки (визуализация)
--- timmax.tilegame.game.minesweeper.jfx.control - контроллеры (приём команд от мыши и клавиатуры)
-- Модуль MinesweeperGame - различные варианты запуска
   (думаю, что и этот модуль нужно разделить на несколько - по количеству видов сборки, но зато архитектуру стоит
   унифицировать и уйти от конкретной игры в сборке)
--- timmax.tilegame.game.minesweeper.all_in_one - в сборке и модель и выборки с контроллерами - исполняемый модуль не
    работает с сетью (только для игр с одним игроком).
--- timmax.tilegame.game.minesweeper.server.websocket - сборка только модели, запускаемой как сервер и работающий
    по WebSocket протоколу. Никакого GUI не предусмотрено.
    Будет допускать подключение более чем одного игрока и наблюдателей.
--- timmax.tilegame.game.minesweeper.client.websocket - сборка только клиента (выборки и контроллеры),
    который может подключиться к серверу по WebSocket протоколу. Будет работать как игрок или наблюдатель.
--- timmax.tilegame.game.minesweeper.client.websocket.jfx - реализация клиентского GUI через JavaFX.


10.10.2023 ------------------------------------------------------------------------------------------------------------

(10.10.2023)
MinesweeperGameStackPaneController
- В контроллере Minesweeper есть код, обращающийся к модели к состоянию игры. А этим должны заниматься выборки,
  а не контроллеры! Например, в отдельный метод, который вызывать при каждом поступлении любой команды.
-- Убрать в модель.
-- удалить геттеры в моделях.

(10.10.2023)
SokobanGameSceneController
- В контроллере SokobanGame есть код, обращающийся к модели к состоянию игры. А этим должны заниматься выборки,
  а не контроллеры! Например, в отдельный метод, который вызывать при каждом поступлении любой команды.
-- Убрать в модель.
-- удалить геттеры в моделях.

(10.10.2023) Отказ от реализации.
View, ViewJfx (и наследники)
- Класс View сейчас не используется, но там есть базовый функционал. Нужно отрефакторить ViewJfx, что-бы было использование.

(27.09.2023)
BaseModel
- Дополнить модель очередью команд. Именно в эту очередь должны писать контроллеры.


15.10.2023 ------------------------------------------------------------------------------------------------------------

(15.10.2023)
MinesweeperModel
- Исправлена ошибка в модели Сапёра: при попытке инвертировать флаг на уже открытой плитке исключение возникало
  (о том, что инвертировать флаг для открытой плитки нельзя), и оно же вываливалось и в консоль.

(15.10.2023) частично
BaseModel
- BaseModel сделать интерфейсом. В нём продекларировать те же методы, что сейчас у BaseModel.
  Такой подход уменьшит количество переименований по всем пакетам - модулям проекта.
-- Текущий BaseModel сделать ServerBaseModel, реализующий новый BaseModel.


26.10.2023 ------------------------------------------------------------------------------------------------------------

(07.10.2023) Отказ от реализации очередей.
Архитектура
BaseModel
- Сейчас в BaseModel в исходящую очередь добавляются сообщения, а при вызове notify вызываются update, каждой
  присоединённой view. Такое подходит, когда модель и выборка в одном исполняемом коде.
  Для сетевого взаимодействия нужно разделить функционал на:
-- 1. М: внесению сообщений от модели в очередь модели,
-- 2. М: передача по сети сообщений из очереди модели,
-- 3. В: приём по сети сообщений в выборке,
-- 4. В: внесение в очередь входящих сообщений на стороне выборки,
-- 5. В: известить модель (дать отклик), что сообщение получено,
-- 6. М: если модель получила отклик, что сообщение получено выборкой, то удалить его из своей очереди,
-- 7. В: вызов update на стороне выборки,
-- 8. В: удаление сообщения из очереди выборки.

(10.10.2023) Отказ от реализации очередей.
BaseModel, ...View
- Сейчас очереди сообщений (от модели к выборкам) находятся в модели (т.к. реализована сборка типа "всё-в-одном").
  Для последующей реализации других вариантов сборки нужно создать свои экземпляры очередей в каждой из выборок.
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очереди в модели в очереди в выборки.

(10.10.2023) Отказ от реализации очередей.
BaseModel, ...Controller
- Кроме того, что в модели должна появиться очередь команд, в каждом из контроллеров должна также появиться своя очередь
  команд.
-- И для варианта всё-в-одном написать пакет классов для передачи сообщений из очередей в контроллерах в очередь в модели.

(07.10.2023)
Архитектура
- Создать отдельный пакет в BaseModel (модуль потом) с данными для авторизации: имя / пароль, и парой готовых записей.

(30.09.2023)
Архитектура
WebSocketModel и WebViewControlJfx
- Создать отдельные модули по запуску только модели и только клиента:
-- Оба модуля с использованием WebSocket.
-- Вероятно конкретные названия модулей будут:
--- WebSocket...Model.
--- WebViewControl...Jfx.


30.10.2023 ------------------------------------------------------------------------------------------------------------

(30.10.2023) Отказ от реализации
BaseModel
TransportPackage
- Оптимизация наследников TransportPackage
  Сейчас initMapOfStructOfTransportPackage() реализован в классах наследниках. Из-за этого в них приходится дублировать
  конструкторы.
  Предлагается реализовать initMapOfStructOfTransportPackage() в отдельном сервисном классе и аргументом ему передавать
  this.getClass().
  Тогда классы-наследники этого класса удалим.

(27.09.2023) Отказ от реализации очередей.
Архитектура
BaseModel
- Текущий вариант очереди сообщений содержит в себе не первичное изменение в модели, а то, что изменилось в результате
  одного хода. Для выборок, которые и не должны понимать модель полностью, это норм. Но для модели достаточно было-бы
  записывать только именно первичный ход, который может привести к каскадным изменениям (зависимым ходам).
  Тогда такой лог будет:
-- меньше,
-- не будет неоднозначности,
-- его проще будет повторить от начала до конца.

(27.09.2023) Отказ от реализации очередей.
BaseModel
- Очередь сообщений изменить:
-- Каждая из выборок, подключающаяся к модели, должна заявить, на какой перечень типов сообщений она подписывается.
-- Модель должна писать в одну очередь все события, на которые были подписки. Если есть событие,
   на которое не было подписки - оно не пишется в очередь.
-- Чтение из очереди отдельно взятой выборкой не должно приводить к удалению прочтённого сообщения.
   Но где-то в очереди нужно фиксировать, что такая-то выборка прочитала последнее такое-то сообщение.
-- Удаление сообщения из очереди должно происходить тогда, когда сообщение было прочитано всеми выборками.
-- Если какое-то представление подключается не с начала партии, то модель должна выдать ему полное состояние игры на
   момент подключения. Ну и лучше, что-бы другие представления не читали эти сообщения и хорошо-бы что-бы после
   получения этих сообщений в дальнейшем эта выборка не читала других подобных сообщений для других подключаемых выборок.

10.11.2023 ------------------------------------------------------------------------------------------------------------

(09.11.2023)
GameClients
- Если сразу после запуска приложения закрыть его, то приложение закроется. Но если сделать соединение с сервером и
  попытаться закрыть соединение, то окно приложения закроется, а приложение останется в памяти. Если-же после запуска
  приложения сделать соединение, потом разъединение, то приложение закроется.
  (Вероятно при установлении соединения запускается нить-поток. И даже если закрыть GUI приложения, то нить всё ещё
  продолжает работу).
-- Нужно отловить событие JavaFX о закрытии GUI (например при щелчке на крестике) и завершить все дочерние потоки.


12.11.2023 ------------------------------------------------------------------------------------------------------------

- Реализовать в протоколе и в применении обмен сообщением типа GET_GAME_TYPE_SET